---
id: usaco-491
source: USACO Silver 2014 December
title: Piggy Back
author: Qi Wang
---

[Official Analysis](http://www.usaco.org/current/data/sol_piggyback_silver.html)

**Time Complexity:** $\mathcal{O}(N)$

<LanguageSection>
<JavaSection>
	

## C++ Implementation

```cpp
	#include <bits/stdc++.h>

	using namespace std;

	typedef long long ll;
	typedef long double ld;
	typedef unsigned long long ull;
	#define pb push_back
	#define F first
	#define S second
	#define ii pair<ll,ll>
	const long double eps=1e-16;
	const ll N = 3e5 + 5, M = 3e5 + 50, LOG = 21, mod = 1000000007, INF = 1e18;
	const ld EPS = 1e-16;
	int n,m;

	vector<int> adj[N];

	int arr[N];
	int vis[N];
	int vid=0;
	int dis[3][N];
	int cost[3];
	int st[3]{0,1,0};
	int main() {
	//    ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0);
	    freopen("piggyback.in","r",stdin);
	    freopen("piggyback.out","w",stdout);
	    ll tt = 1;
	    while (tt--) {
		int x,y;
		int b,e,p;
		cin >> cost[0]>>cost[1]>>cost[2]>>n >> m;
	
		st[2]=n-1;
		for (int i = 0; i < m; ++i) {
		    int a,b;
		    cin >>a>>b;
		    a--,b--;
		    adj[a].push_back(b);
		    adj[b].push_back(a);
		}
	// The soultion is about trying to choose the meeting point
	// So the will spend some x*E + y*B + z*P
		int ans=m;
	// Run bfs to get the distance to every node
		for (int i = 0; i < 3; ++i) {
		    queue<int>qu;
		    vid++;
		    qu.push(st[i]);
		    vis[st[i]]=vid;
		    dis[i][st[i]]=0;
		    while(!qu.empty()){
			auto cur=qu.front();
			qu.pop();
			for(auto e:adj[cur]){
			    if(vis[e]!=vid){
				qu.push(e);
				vis[e]=vid;
				dis[i][e]=dis[i][cur]+cost[i];
			    }
			}
		    }

		}
		int mn=1e9;
		for(int i=0;i<n;i++){
		    mn=min(mn,dis[0][i]+dis[1][i]+dis[2][i]);
		}
		cout <<mn <<endl;
	    }
	}
```

## Java Implementation

```java
import java.util.*;
import java.io.*;

public class PiggyBack {
	static int B, E, P, N, M, A = Integer.MAX_VALUE;
	static List<Integer>[] adj;
	static int[][] dist;
	public static void main(String[] args) throws Exception {
		Kattio io = new Kattio("piggyback");

		B = io.nextInt();
		E = io.nextInt();
		P = io.nextInt();
		N = io.nextInt();
		M = io.nextInt();

		adj = new List[N];
		dist = new int[3][N];

		for (int i = 0; i < 3; i++) {
			Arrays.fill(dist[i], -1);
		}

		for (int i = 0; i < N; i++) {
			adj[i] = new ArrayList<>();
		}

		for (int i = 0; i < M; i++) {
			int a = io.nextInt() - 1;
			int b = io.nextInt() - 1;

			adj[a].add(b);
			adj[b].add(a);
		}


		bfs(0, 0);
		bfs(1, 1);
		bfs(N-1, 2);

		for (int i = 0; i < N; i++) {
			A = Math.min(A, dist[0][i] * B + dist[1][i] * E + dist[2][i] * P);
		}


		io.println(A);
		io.close();
	}

	private static void bfs(int s, int ix) {
		Queue<Path> q = new LinkedList<>();
		q.add(new Path(s, 0));
		dist[ix][s] = 0;

		while(!q.isEmpty()) {
			Path curr = q.poll();

			for (Integer n : adj[curr.i]) {
				if(dist[ix][n] != -1) continue;
				dist[ix][n] = curr.d + 1;

				q.add(new Path(n, dist[ix][n]));
			}
		}
	}

	private static class Path {
		int i, d;
		public Path(int a, int b) {
			i = a;
			d = b;
		}
	}

	//CodeSnip{Kattio}
}
```

</JavaSection>
</LanguageSection>
